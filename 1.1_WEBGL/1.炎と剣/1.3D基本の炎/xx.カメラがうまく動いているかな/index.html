<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Particle System with Rotating Camera and Static Object</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
</head>
<body>
    <canvas id="glcanvas" width="800" height="600"></canvas>
</body>
<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');

// シェーダープログラムの初期化
const vertexShaderSource = `
    attribute vec3 a_position;
    attribute vec3 a_velocity;
    attribute float a_lifetime;
    attribute vec4 a_startColor;
    attribute vec4 a_endColor;
    varying vec4 v_color;
    varying float v_size;
    uniform float u_time;
    uniform mat4 u_projection;
    uniform mat4 u_view;
    uniform vec3 u_offset;
    void main() {
        float progress = mod(u_time, a_lifetime) / a_lifetime;
        vec3 gravity = vec3(0.0, -0.05, 0.0) * progress;
        vec3 position = a_position + (a_velocity + gravity) * progress + u_offset;
        v_color = mix(a_startColor, a_endColor, progress);
        v_size = mix(6.0, 1.0, progress);
        gl_Position = u_projection * u_view * vec4(position, 1.0);
        gl_PointSize = v_size;
    }
`;

const fragmentShaderSource = `
    precision mediump float;
    varying vec4 v_color;
    void main() {
        gl_FragColor = v_color;
    }
`;

function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

function createProgram(gl, vertexShader, fragmentShader) {
    const program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error(gl.getProgramInfoLog(program));
        gl.deleteProgram(program);
        return null;
    }
    return program;
}

const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
const program = createProgram(gl, vertexShader, fragmentShader);

const aPositionLocation = gl.getAttribLocation(program, 'a_position');
const aVelocityLocation = gl.getAttribLocation(program, 'a_velocity');
const aLifetimeLocation = gl.getAttribLocation(program, 'a_lifetime');
const aStartColorLocation = gl.getAttribLocation(program, 'a_startColor');
const aEndColorLocation = gl.getAttribLocation(program, 'a_endColor');
const uTimeLocation = gl.getUniformLocation(program, 'u_time');
const uProjectionLocation = gl.getUniformLocation(program, 'u_projection');
const uViewLocation = gl.getUniformLocation(program, 'u_view');
const uOffsetLocation = gl.getUniformLocation(program, 'u_offset');

const numParticles = 2000;
const positions = new Float32Array(numParticles * 3);
const velocities = new Float32Array(numParticles * 3);
const lifetimes = new Float32Array(numParticles);
const startColors = new Float32Array(numParticles * 4);
const endColors = new Float32Array(numParticles * 4);

for (let i = 0; i < numParticles; i++) {
    positions[i * 3] = (Math.random() - 0.5) * 0.2;
    positions[i * 3 + 1] = -0.5;
    positions[i * 3 + 2] = (Math.random() - 0.5) * 0.2;
    velocities[i * 3] = (Math.random() - 0.5) * 0.05; // 速度を半分に
    velocities[i * 3 + 1] = (Math.random() * 0.1 + 0.05); // 速度を半分に
    velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.05; // 速度を半分に
    lifetimes[i] = (Math.random() * 1.0 + 0.6); // 寿命を長く
    startColors[i * 4] = 1.0;
    startColors[i * 4 + 1] = 0.5;
    startColors[i * 4 + 2] = 0.0;
    startColors[i * 4 + 3] = 1.0;
    endColors[i * 4] = 1.0;
    endColors[i * 4 + 1] = 0.2;
    endColors[i * 4 + 2] = 0.0;
    endColors[i * 4 + 3] = 0.0;
}

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

const velocityBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
gl.bufferData(gl.ARRAY_BUFFER, velocities, gl.STATIC_DRAW);

const lifetimeBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, lifetimeBuffer);
gl.bufferData(gl.ARRAY_BUFFER, lifetimes, gl.STATIC_DRAW);

const startColorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, startColorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, startColors, gl.STATIC_DRAW);

const endColorBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, endColorBuffer);
gl.bufferData(gl.ARRAY_BUFFER, endColors, gl.STATIC_DRAW);

// 立方体のためのバッファとシェーダー
const cubeVertices = new Float32Array([
    -0.5, -0.5, -0.5,
     0.5, -0.5, -0.5,
     0.5,  0.5, -0.5,
    -0.5,  0.5, -0.5,
    -0.5, -0.5,  0.5,
     0.5, -0.5,  0.5,
     0.5,  0.5,  0.5,
    -0.5,  0.5,  0.5,
]);

const cubeIndices = new Uint16Array([
    0, 1, 2,  2, 3, 0,
    4, 5, 6,  6, 7, 4,
    0, 1, 5,  5, 4, 0,
    2, 3, 7,  7, 6, 2,
    0, 3, 7,  7, 4, 0,
    1, 2, 6,  6, 5, 1,
]);

const cubeVertexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

const cubeIndexBuffer = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

const cubeVertexShaderSource = `
    attribute vec3 a_position;
    uniform mat4 u_model;
    uniform mat4 u_view;
    uniform mat4 u_projection;
    void main() {
        gl_Position = u_projection * u_view * u_model * vec4(a_position, 1.0);
    }
`;

const cubeFragmentShaderSource = `
    precision mediump float;
    void main() {
        gl_FragColor = vec4(0.5, 0.5, 0.5, 1.0);
    }
`;

const cubeVertexShader = createShader(gl, gl.VERTEX_SHADER, cubeVertexShaderSource);
const cubeFragmentShader = createShader(gl, gl.FRAGMENT_SHADER, cubeFragmentShaderSource);
const cubeProgram = createProgram(gl, cubeVertexShader, cubeFragmentShader);

const aCubePositionLocation = gl.getAttribLocation(cubeProgram, 'a_position');
const uCubeModelLocation = gl.getUniformLocation(cubeProgram, 'u_model');
const uCubeViewLocation = gl.getUniformLocation(cubeProgram, 'u_view');
const uCubeProjectionLocation = gl.getUniformLocation(cubeProgram, 'u_projection');

gl.useProgram(program);
gl.enableVertexAttribArray(aPositionLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.vertexAttribPointer(aPositionLocation, 3, gl.FLOAT, false, 0, 0);

gl.enableVertexAttribArray(aVelocityLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, velocityBuffer);
gl.vertexAttribPointer(aVelocityLocation, 3, gl.FLOAT, false, 0, 0);

gl.enableVertexAttribArray(aLifetimeLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, lifetimeBuffer);
gl.vertexAttribPointer(aLifetimeLocation, 1, gl.FLOAT, false, 0, 0);

gl.enableVertexAttribArray(aStartColorLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, startColorBuffer);
gl.vertexAttribPointer(aStartColorLocation, 4, gl.FLOAT, false, 0, 0);

gl.enableVertexAttribArray(aEndColorLocation);
gl.bindBuffer(gl.ARRAY_BUFFER, endColorBuffer);
gl.vertexAttribPointer(aEndColorLocation, 4, gl.FLOAT, false, 0, 0);

const projectionMatrix = mat4.create();
const viewMatrix = mat4.create();
const modelMatrix = mat4.create();

mat4.perspective(projectionMatrix, Math.PI / 4, canvas.width / canvas.height, 0.1, 100);

const cameraRadius = 3;
const cameraHeight = 1;
const zoomSpeed = 0.02;
let zoomDirection = 1;

function drawScene(time) {
    time *= 0.001;  // convert to seconds

    let cameraX = Math.sin(time) * cameraRadius;
    let cameraZ = Math.cos(time) * cameraRadius;
    let cameraY = Math.sin(time * 0.5) * 0.5 + cameraHeight;
    
    // カメラのズームイン・ズームアウトの実装
    const zoom = Math.sin(time * zoomSpeed) * 2 + 5;
    mat4.lookAt(viewMatrix, [cameraX, cameraY, cameraZ], [0, 0, 0], [0, 1, 0]);
    mat4.scale(viewMatrix, viewMatrix, [zoom, zoom, zoom]);

    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // Cubeの描画
    gl.useProgram(cubeProgram);
    mat4.identity(modelMatrix);
    mat4.scale(modelMatrix, modelMatrix, [0.3, 0.3, 0.3]); // 立方体のサイズを1/3に縮小
    gl.uniformMatrix4fv(uCubeModelLocation, false, modelMatrix);
    gl.uniformMatrix4fv(uCubeViewLocation, false, viewMatrix);
    gl.uniformMatrix4fv(uCubeProjectionLocation, false, projectionMatrix);

    gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
    gl.vertexAttribPointer(aCubePositionLocation, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(aCubePositionLocation);

    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeIndexBuffer);
    gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

    // Particleの描画
    gl.useProgram(program);
    gl.uniform1f(uTimeLocation, time);
    gl.uniformMatrix4fv(uProjectionLocation, false, projectionMatrix);
    gl.uniformMatrix4fv(uViewLocation, false, viewMatrix);

    for (let i = 0; i < 20; i++) {
        gl.uniform3f(uOffsetLocation, (Math.random() - 0.5) * 2, 0, (Math.random() - 0.5) * 2);
        gl.drawArrays(gl.POINTS, 0, numParticles);
    }

    requestAnimationFrame(drawScene);
}

gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.enable(gl.DEPTH_TEST);
requestAnimationFrame(drawScene);
</script>
</html>
